   #include<bits/stdc++.h>
   #include<ext/pb_ds/assoc_container.hpp>
   #include<ext/pb_ds/tree_policy.hpp>
   using namespace __gnu_pbds;
   using namespace std;
   #define fast ios_base::sync_with_stdio(false),cout.tie(NULL),cin.tie(NULL);
   #define N "\n";
   #define all(v) v.begin(),v.end()
   #define rall(v) v.rbegin(),v.rend()
   #define sz(s) s.size()
   typedef  long long ll;
   typedef  long double ld;
   typedef  unsigned long long ull;
   #define ull unsigned long long
   #define TxtIO   freopen("input.txt","r",stdin); freopen("output.txt","w",stdout);
   #define M_PI   3.14159265358979323846 
   const int MOD=1e9+7,M=2e5+1;
   ll mul(ll a,ll b){return (1ll*a*b)%MOD;}
   int sub(ll a,ll b){return ((a-b)%MOD+MOD)%MOD;}
   int add(ll a,ll b){return ((a%MOD)+(b%MOD))%MOD;}
   ll lcm(ll x, ll y) {return x / __gcd(x, y) * y;}
   bool iseven(ll n) {if ((n & 1)){return 0;}else {return 1;}}
   ll ncr(ll n,ll m){ll z=1;for(ll i=0;i<m;i++){z=z*(n-i)/(i+1);}return z;}
   void swp(ll &a,ll &b){a^=b;b^=a;a^=b;}
   ll fp(int n,int p){if(!p){return 1;}ll rem=fp(n,p>>1);rem*=rem;if(p&1){rem*=n;}return rem;}
   int dx[]={1,0,0,-1,1,1,-1,-1};
   int dy[]={0,-1,1,0,1,-1,1,-1};
   #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update
   vector<bool>isPrime;
   vector<int>prime;
   void linearSieve(ll n){
      prime.clear();
      isPrime=vector<bool>(n,1);
      isPrime[0]=isPrime[1]=0;
      for(int i=2;i<n;i++){
         if(isPrime[i])prime.push_back(i);
         for(int j=0;j<prime.size()&&i*prime[j]<M;j++){
            isPrime[i*prime[j]]=0;
            if(i%prime[j]==0)break;
         }
      }
   }
   int factorize(ll n){
      int sum=0;
      if(n%2==0){
         while(n%2==0){
            sum++;
            n/=2;
         }
      }
      for(ll i=3;i*i<=n;i+=2){
         if(n%i==0){
            while(n%i==0){
               sum++;
               n/=i;
            }
         }
      }
      if(n!=1){sum++;}
      return sum;
   }
   vector<ll> fact,invfact;
   ll modpow(ll a, ll e){
      ll res=1;
      a%=MOD;
      while(e){
         if(e&1)res=(res*a)%MOD;
         a=(a*a)%MOD;
         e>>=1;
      }
      return res;
   }
   void precompute_factorials(){
      fact.assign(M+1,1);
      for(int i=1;i<=M;i++)fact[i]=fact[i-1]*i%MOD;
      invfact.assign(M+1,1);
      invfact[M]=modpow(fact[M],MOD-2);
      for(int i=M-1;i>=0;i--)invfact[i]=invfact[i+1]*(i+1)%MOD;
   }
   ll nCr_mod(int n,int r){
      if(r<0||r>n)return 0;
      return fact[n]*invfact[r]%MOD*invfact[n-r]%MOD;
   }
   struct Fenwick{
      int n;
      vector<int>bit;
      Fenwick(int n=0):n(n),bit(n+1,0) {}
      void add(int idx,int val){for(;idx<=n;idx+=idx&-idx)bit[idx]+=val;}
      int sum(int idx){
         int r=0;
         for(;idx>0;idx-=idx&-idx)r+=bit[idx];
          return r;
      }
      void range_add(int l,int r,int val){
         if(l>r)return;
         add(l,val);
          if(r+1<=n)add(r+1,-val);
      }
   };
   bool cmp(const pair<int,int>&i,const pair<int,int>&j){
      if(i.first==j.first){
         return i.second>j.second;
      }
      return i.first>j.first;
   }
   int main(){
      fast
      // precompute_factorials();
      int t=1;
      // cin>>t;
      while(t--){
         int l1,r1,l2,r2;
         cin>>l1>>r1>>l2>>r2;
         int n;
         cin>>n;
         map<pair<int,int>,bool>can;
         map<pair<int,int>,int>vis;
         for(int i=0;i<n;i++){
            int r,a,b;
            cin>>r>>a>>b;
            for(int j=a;j<=b;j++){
               can[{r,j}]=1;
               vis[{r,j}]=INT_MAX;
            }
         }
         queue<pair<pair<int,int>,int>>q;
         q.push({{l1,r1},0});
         vis[{l1,r1}]=0;
         while(!q.empty()){
            auto nw=q.front();
            q.pop();
            for(int i=0;i<8;i++){
               int nwx=nw.first.first+dx[i];
               int nwy=nw.first.second+dy[i];
               if(can.count({nwx,nwy})&&nw.second+1<vis[{nwx,nwy}]){
                  vis[{nwx,nwy}]=nw.second+1;
                  q.push({{nwx,nwy},nw.second+1});
               }
            }
         }
         if(vis[{l2,r2}]==INT_MAX){
            cout<<-1;
            continue;
         }
         cout<<vis[{l2,r2}];
      }
   }
